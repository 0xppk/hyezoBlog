---
title: "클로저의 의미"
date: '2022-11-29'
categories: coding
tags: 자바스크립트
description: 클로저
---
<HeadingNavigator />

### 전략적으로 이해하기
자바스크립트를 기초부터 공부하면서 클로저란 용어만큼 낯설었던 게 없다.  
리액트 유저라면 밥먹듯이 쓰고 있는 건데 정작 그 개념, 또는 원리에 대해서는 몰랐던 거시다... 그게 무슨 문제지? 라고 생각하는 사람이 있을 테고, 바로 내가 그랬다. 악기를 다루는 것이 중요하지 만드는 법까지 알아야 하나? 배부른 생색내기가 아닌가 싶었던 것이다.  
<br/>
하지만 그런 손재주 좋은 사람이 도구를 <i>전략적으로도</i> 이해까지 해버렸을 때, 그런 사람에게 더 많은 자유가 주어지리라는 것은 주지의 사실인 것 같다. 짧은 시간이지만 이를(그러니까 내가 가진 한계를) 경험적으로 느끼게 되었다.  
<br/>
그래서 오늘의 주제는 클로저다. 하지만 이를 이해하기 위해서는 스코프라는 개념을 먼저 알아야 했다.

### 스코프
자바스크립트의 함수는 스코프라는 행동범위(일종의 도화지)를 가지고 있다. 쉽게 말해 함수의 중괄호(`{}`) 영역인데, <i>var 변수의 유효 범위는 함수 스코프다</i>, 라는 말에서 아마 이를 처음 들었던 것 같다.  
<br/>
모든 함수는 이처럼 스코프를 가지고 있다. 가장 최상단에 있는 스코프는 전역 스코프(global scope)고, 리액트에서 우리는 보통 한 파일, 모듈 단위로 작업하므로 이는 좀 작아지면 모듈 스코프(module scope)가 될 것이다.  
이런 말들에서 암시되고 있는 건 **스코프에는 위계가 있다**는 것이다. 이를 이해하는 건 매우 중요한데, 왜냐면 스코프는 자기 내부에서 자기가 모르는 어떤 변수가 사용되고 있을 때, 이를 상위 스코프를 거슬러 오르며 찾아내기 때문이다.  
사람들은 이것을 `스코프 체인(scope chain)`이라 부르기로 했다. 아마 프로토타입 체인과 더불어 자바스크립트를 이해하는 데 가장 중요한 개념이지 않을까?

### 클로저
그래서 클로저란 바로 이런 스코프 체인을 활용한 일종의 함수 테크닉이다. 그러니까 클로저 함수란 자기의 파라미터도, 그렇다고 함수 내부에서 만들어진 변수도 아닌 어떤 값을 자기 바깥에서 가져오는 함수를 의미한다.  
달리 말해 어떤 함수와 그 내부의 함수는 **일종의 부모-자식 쌍**이라서(모든 함수는 스코프를 가진다는 것을 기억하자!), 부모의 값은 자식값에서 활용될 수 있다는 뜻이다. 간단한 예시로 클로저의 움직임을 살펴보자
```js test.js
  function sum3(x, y, z) {
    return x + y + z;
  }
  
  console.log(sum3(1, 2, 3) // 6
```
먼저 이건 일반적인 상황이다. 세 개의 파라미터를 받는 함수가 있고, 그 값들은 스코프 안에서 모두 더해져 리턴되고 있다. 여기서 `1, 2, 3`을 인수로 전달했을 때 리턴값이 `6`이라는 걸 상상하기는 어렵지 않을 것 같다. 하지만 이를 클로저의 형태로 표현하면 살짝 생경해진다.

```js test.js
function sum3(x) {
  return (y) => {
    return (z) => {
      return x + y + z;
    };
  };
}
console.log(sum3(1)(2)(3)) // 6
```
모양이 달라졌다. 함수 `sum3()`는 하나의 파라미터 `x` 만을 받고 그 스코프는 익명함수를 리턴한다. 언뜻 그런 구조가 반복되고 마지막 z-함수가 모든 파라미터를 더해서 리턴하는 게 보인다. 이제 `1, 2, 3`을 각자의 인수로 전해보면? 그 값은 똑같이 `6`이 된다.  
<br/>
이는 스코프 체인에 의한 클로저의 동작을 보여준다. 가장 깊이 있는 z-함수는 자신의 파라미터 `z` 만을 알고 나머지 두 변수 `x, y`에 대해서는 몰라야 한다. 하지만 스코프 체인에 의해 자기를 품고 있는 상위 스코프를 참조하고, 거기서 `y`, 또 `x`를 발견하여 가져오고 있는 것이다.    
이렇듯 클로저란 안쪽에서 바깥 스코프를 참조하는 함수를 가리킨다.

### 렉시컬 스코프
이때 유의할 점이 있다. 클로저 함수는 호출할 때가 아니라 자기가 선언될 때를 기준으로 스코프 체인을 인식한다. 다시 말해 클로저가 처음 설계된 그 자리를 기준으로 인접한 스코프를 찾아내는 것이다. 가령 예를 들면
```js test.js
(function() {
  const x = 1;
  function 클로저선언() {
    console.log(x);
  }
  function 클로저호출(fn) {
    const x = 10;
    fn()
  }
  return 클로저호출(클로저선언)
})()
```
이 IIFE 함수에선 `x` 값이 어떻게 뜨냐가 관건이다. 어떻게 뜰까? 앞서 말했듯 스코프 체인은 함수가 호출되는 곳이 아닌 선언되는 곳를 기준으로 삼는다. 때문에 `클로저선언()`은 자기가 선언된 시점의 바깥 스코프(`const x = 1`이 들어있는) 환경을 기억, `1`을 출력한다.  
이처럼 자기가 태어난 스코프 환경을 정적으로 또 일관되게 기억하는 것, 그걸 사람들은 렉시컬(스태틱) 스코프라고 부른다.

#### 렉시컬?
모든 낱말들이 자신 안에 어원이라는 계보를 가지듯, 함수 또한 *자기의 모체에 대한 기억*을 간직한다. `lexical`이라는 작명은(어휘의, 사전의) 그런 연유에서 탄생하지 않았을까 싶다.

### 정리
클로저는 `스코프 체인`이라는 거대한 흐름을 이용하는 자바스크립트 함수의 한 속성이다. 여기서 중요한 건 스코프 체인이고, 클로저는 파생물이라면 오만한 말일지 모르겠다. 어쨌든 나는 그렇게 느꼈다. 스코프 체인을 이해하려 노력하면서 컨텍스트나 화살표 함수에 대한 이해도 진전됐다.


함수가 호출될 때마다 함수 컨텐스트가 생성된다.
함수 컨텍스트에는 `변수객체(args, variables), 스코프 체인, this`가 담긴다.
스코프 체인은 함수가 호출되는 곳이 아닌 선언되는 곳을 기준으로 삼는다.
화살표 함수의 컨텍스트에는 this가 포함되지 않는다. 자체의 this를 바인딩하지 않기 때문에 스코프 체인에 의해 바깥 스코프의 this를 참조한다.