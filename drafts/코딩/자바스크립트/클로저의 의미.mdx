---
title: "클로저의 의미"
date: '2022-11-29'
categories: coding
tags: 자바스크립트
description: 클로저
---
<HeadingNavigator />

### 전략적으로 이해하기
자바스크립트를 기초부터 공부하면서 클로저란 용어만큼 새삼 낯설었던 것도 또 없었다. 리액트 유저라면 밥먹듯이 쓰는 거지만 정작 그 개념, 또는 원리에 대해서는 모르쇠였던 거다. 그게 무슨 문제지? 라고 생각할 수 있고, 나도 그랬다. 악기를 다룰 줄만 알면 되지 만드는 법까진 알 필요 없다고 말이다. 하지만 그런 손재주 좋은 사람이 도구를 <i>전략적으로도</i> 이해까지 해버렸을 때, 나쁠 건 없다는 건 주지의 사실인 것 같다(적어도 코딩에서는 그렇다. 창작이라면 지나친 지식이 족쇄가 될 수 있겠지만).  
그럼 오늘의 주제로. 클로저란 뭘까? 이를 이해하기 위해서는 스코프라는 개념을 먼저 알아야 했다.

### 스코프
자바스크립트의 함수는 스코프라는 행동범위(일종의 도화지)를 가지고 있다. 쉽게 말해 함수의 중괄호(`{}`) 영역인데, var 변수의 유효 범위는 함수 스코프다, 라는 말에서 아마 이를 처음 들었던 것 같다.  
모든 함수는 이처럼 스코프를 가지고 있다. 그리고 가장 최상단에 있는 스코프는 전역 스코프(global scope)다. 리액트에서 우리는 보통 한 파일, 모듈 단위로 많이 작업하므로 이는 좀 작아져 모듈 스코프(module scope)가 될 것이다.  
이런 말들이 암시하고 있는 건 **스코프에 위계가 있다**는 거다. 이를 이해하는 건 매우 중요하다. 왜냐면 스코프는 자기 내부에서 자기가 모르는 어떤 변수가 사용됐을 때, 상위 스코프를 거슬러 오르며 이 값을 찾아내기 때문이다. 이것이 바로 `스코프 체인(scope chain)`이다.
아마 프로토타입 체인과 더불어 자바스크립트를 이해하는 데 가장 중요한 개념이 아닐까? 생각했다.

### 클로저
그래서 클로저란 바로 이런 스코프 체인을 활용하여 자기의 파라미터도, 그렇다고 함수 내부에서 만들어진 변수도 아닌 어떤 값을 자기 바깥에서 가져오는 함수를 의미한다.  
즉 어떤 함수와 그 내부의 함수는 **일종의 부모-자식 쌍**이라서, 부모의 값은 자식값에서 활용될 수 있다는 뜻이다. 간단한 예시로 클로저의 움직임을 살펴보자
```js test.js
  function sum3(x, y, z) {
    return x + y + z;
  }
  
  console.log(sum3(1, 2, 3) // 6
```
먼저 이건 일반적인 상황이다. 세개의 파라미터를 받는 함수가 있고, 그 값들은 스코프 안에서 모두 더해져 리턴되고 있다. 여기서 `1, 2, 3`을 인수로 전달했을 때 리턴값이 `6`이라는 걸 상상하기는 그리 어렵지 않을 것 같다. 이를 클로저의 형태로 표현하면 허나 살짝 생경하게 보일 수 있다.

```js test.js
function sum3(x) {
  return (y) => {
    return (z) => {
      return x + y + z;
    };
  };
}
console.log(sum3(1)(2)(3)) // 6
```
모양이 달라졌다. 함수 `sum3()`는 하나의 파라미터 `x` 만을 받고 그 스코프는 익명함수를 리턴한다. 언뜻 그런 구조가 반복되고 마지막 z-함수가 모든 파라미터를 더해서 리턴하는 게 보인다. 이제 `1, 2, 3`을 각자의 인수로 전해보자. 그리고 그 값은 똑같이 `6`이다.  
이는 스코프 체인에 의한 클로저의 동작을 보여주고 있다. 가장 깊이 있는 z-함수는 자신의 파라미터 `z` 만을 알고 나머지 두 변수 `x, y`에 대해서는 몰라야 한다. 하지만 스코프 체인에 의해 자기를 품고 있는 상위 스코프를 참조하고, 거기서 `y`, 또 `x`를 발견하여 가져오고 있는 것이다.  
이렇듯 클로저란 안쪽에서 바깥 스코프를 참조하는 함수를 가리킨다.

### 렉시컬 스코프
이때 유의할 점이 있다. 클로저 함수는 호출할 때가 아니라 자기가 선언될 때를 기준으로 스코프 체인을 인식한다. 다시 말해 클로저가 처음 설계된 그 자리를 기준으로 인접한 스코프를 찾아내는 것이다. 가령 예를 들면
```js test.js
(function() {
  const x = 1;
  function 클로저선언() {
    console.log(x);
  }
  function 클로저호출(fn) {
    const x = 10;
    fn()
  }
  return 클로저호출(클로저선언)
})()
```
이 IIFE 함수에선 `x` 값이 어떻게 뜨냐가 관건이다. 어떻게 뜰까? 앞서 말했듯 스코프 체인은 함수가 호출되는 곳이 아닌 선언되는 곳를 기준으로 삼는다. 때문에 여기서 `클로저선언()`은 자기가 선언된 시점의 바깥 스코프(`const x = 1`이 들어있는) 환경을 기억, `1`을 출력한다.  
이처럼 자기가 태어난 스코프 환경을 정적으로 또 일관되게 기억하는 것, 그걸 사람들은 렉시컬(스태틱) 스코프라고 부르기로 했다.

#### 렉시컬?
모든 낱말들이 자신 안에 어원이라는 계보를 가지듯 함수 또한 자기 모체에 대한 기억을 간직한다. `lexical`이라는 작명은(어휘의, 사전의) 그런 연유에서 탄생하지 않았을까 싶다.

### 정리
클로저는 `스코프 체인`이라는 거대한 흐름을 이용하는 자바스크립트 함수의 한 속성이다. 여기서 중요한 건 스코프 체인이고, 클로저는 파생물이라면 오만한 말일지 모르겠다. 어쨌든 나는 그렇게 느꼈다. 스코프 체인을 이해하려 노력하면서 컨텍스트나 화살표 함수에 대한 이해도 진전됐다.


함수가 호출될 때마다 함수 컨텐스트가 생성된다.
함수 컨텍스트에는 `변수객체(args, variables), 스코프 체인, this`가 담긴다.
스코프 체인은 함수가 호출되는 곳이 아닌 선언되는 곳을 기준으로 삼는다.
화살표 함수의 컨텍스트에는 this가 포함되지 않는다. 자체의 this를 바인딩하지 않기 때문에 스코프 체인에 의해 바깥 스코프의 this를 참조한다.