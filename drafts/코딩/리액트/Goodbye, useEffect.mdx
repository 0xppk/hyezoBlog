---
title: "useEffect의 개념 모델"
date: '2023-01-15'
categories: coding
tags: 리액트
description: init 
---
<HeadingNavigator />

### useEffect's mental model
```tsx Effect!
useEffect(() => {
  doSomething();
}, [whenever, these, things, update])
```
<Img src='/images/2023/react/useEffect mental model.webp' />
<figcaption>useEffect는 라이프사이클 도구가 아니에요</figcaption>
<br/>

Effect가 필요하지 않은 상황
- 렌더링을 위해 데이터를 변화시켜야 할 때 `Effect`를 쓸 이유가 없다. 
- 유저와 상호작용 할 때 `Effect`를 쓸 필요가 없다. 이건 이벤트 핸들러에 걸어줘야 함.

Effect가 필요한 상황
- 외부 시스템과 동기화를 위해서는 `Effect`를 사용해야 한다. 

- `props`나 `state`를 이용해 뭔가를 계산할 때 `state`로 처리하지 말것. 일반적인 컨텍스트 변수 `const, let`을 이용해서 렌더링마다 재연산이 이뤄지게 하면 충분하다. 이건 코드를 더 빠르고, 단순하고, 오류가 덜 나게 만든다. 
**When something can be calculated from the existing props or state, don't put it in state. Instead, calculate it during rendering.** This makes your code faster (you avoid the extra "cascading" update), simper(you remove some code), and less error-prone (you avoid bugs caused by different state variables getting out of sync with each other.) If this approach feels new to you, Thinking in React has some guidance on what should go into state.

When using `useMemo` hook, this tells React that you don't want the inner function to re-run unless either todos or filter have changed. React will remember the return value of getFilteredTodos() during the initial render. During the next renders, it will check if todos or filter are different. if they're the same as last time, `useMemo` will return the last result it has stored. But if they are different, React will call the wrapped function again (and store that result instead.)
The function you wrap in `useMemo` runs during rendering, so this only works for pure calculations.

When you write and read Effects, you should think from each individual Effect’s perspective (how to start and stop synchronization) rather than from the component’s perspective (how it mounts, updates, or unmounts).


> Try to think about each Effect independently from your component's lifecycle.
>> Intuitively, you might think that React would start synchronzing when your component mounts and stop synchronizing when your componet unmounts. However, this is not the end of the story! Sometimes, it may also be necessary to start and synchronzing multiple times while the component remains mounted.



#### 참고자료
  1. <Lnk text='Goodbye, useEffect' href='https://www.youtube.com/watch/bGzanfKVFeU' />
  2. <Lnk text='Why I Don’t Use useEffect In My React Components' href='https://www.youtube.com/watch/MFj_S0Nof90' />
  3. <Lnk text='useEffect() is called twice' href='https://stackoverflow.com/questions/60618844/react-hooks-useeffect-is-called-twice-even-if-an-empty-array-is-used-as-an-ar' />
  4. <Lnk text='Rendering twice because of Strict Mode' href='https://stackoverflow.com/questions/61254372/my-react-component-is-rendering-twice-because-of-strict-mode/61897567#61897567' />
  5. <Lnk text='You might not need an Effect' href='https://beta.reactjs.org/learn/you-might-not-need-an-effect' />