---
title: 자바스크립트 정리
date: '2022-11-09'
categories: coding
tags: 자바스크립트
description: 정리
---
<HeadingNavigator />

자바스크립트에 대한 나의 이해 자가진단.. 치부를 드러내라ㄷㄷ 

### 1. 호이스팅
```js
function  sayHi(){
  console.log(name);
  console.log(age);
  var name = "Lydia";
  let age = 21;
}

sayHi();
```
<details open>
  <summary>무엇이 출력될까?</summary>
    <>
      - 내 답 : `undefined`, `ReferenceError`  
      - 이유? : 변수 `var`는 선언과 동시에 scope의 최상단으로 호이스팅된다. 이때 초기화도 같이 이루어지며 기본값은 `undefined`다. 할당값이 붙는 건 그 후다.  
      마찬가지로 `let(const)`도 호이스팅된다. 하지만 `var`와 달리 초기화가 자동으로 되지 않기 때문에 할당이 이루어지기 전까진 값에 접근할 수 없다.  
      - 사족 : 변수처럼 함수도 호이스팅된다. 함수의 기본 형태인 `선언식`들의 경우 순서에 상관없이 서로를 참조/호출한다. 함수 `표현식`이란 이런 함수들을 변수에 묶은 것이고, 그 경우 변수 호이스팅 원칙을 따라 순서에 엄격을 가할 수 있다.
      - 오답노트 : 💯
      <Img src='/images/스샷_호이스팅2.webp' />
      <figcaption>최상단으로 호이스팅되는 함수선언식</figcaption>
      <Img src='/images/스샷_호이스팅1.webp' />
      <figcaption>var 함수표현식</figcaption>
    </>
</details>


### 2. 이벤트 루프
```js
for (var i = 0; i < 3; i++) {
  setTimeout(() => console.log(i), 1);
}

for (let i = 0; i < 3; i++) {
  setTimeout(() => console.log(i), 1);
}
```
<details>
  <summary>무엇이 출력될까?</summary>
    <>
    - 내 답 : 333 012
    - 이유? : 콜백 함수의 큐 시점에 관한 문제인 거 같다. 콜백 함수는 콜 스택 처리에서 후순위에 위치하기 때문에 루프가 다 돌고나서 실행된다. 이때 변수 `var`의 값은 `global`에 묶인다. 콜백이 실행되기 전, 루프를 거친 `var`의 값은 3이다. 어떤 위치에서든 i의 값은 3을 참조한다. 
    반면 `let`의 값은 블록 스코프로서 `{}` 안에 서식한다. 각각의 루프가 진행될 때 변수 i의 값도 스코프(`setTimeout`) 안에 새로이 배정된다. 
    - 사족 : for~let 반복문의 효과는 마치 클로저 함수와 유사하다. 각각의 i값을 `arguments`로 묶어 집어넣은 듯.?!
    - 오답노트 : ⚠️ (클로저와의 유사성 보충 필요)
    </>
</details>

### 3. 화살표 함수 안에서의 this
```js
const shape = {
  radius: 10,
  diameter() {
    return this.radius * 2;
  },
  perimeter: () => 2 * Math.PI * this.radius,
};

console.log(shape.diameter());
console.log(shape.perimeter());
```
<details>
  <summary>무엇이 출력될까?</summary>
    <>
    - 내 답 : 20, NaN
    - 이유? : 화살표 함수 안에서 `this`는 현재 스코프가 아닌 현재 스코프를 감싸고 있는 객체를 참조한다. 따라서 shape의 radius값을 `perimeter()` 메써드에선 알 수 없다(undefined).
    - 사족 : -
    - 오답노트 : 💯
    </>
</details>

### 4. Boolean과 타입들
```js
+true;
!'Lydia';
```
<details>
  <summary>무엇이 출력될까?</summary>
    <>
    - 내 답 : 1, false
    - 이유? : `true`는 1과도 같다.. 덧셈 연산자 +는 true를 숫자로 존재?하게 한다. 또한 어떤 텍스트든 값이 있는 글자는 `true`와도 같다. 여기에 부정논리연산자 !를 더하면 false로 읽게 된다.
    - 사족 : -
    - 오답노트 : 💯
    </>
</details>

### 5. 
```js
let c = { greeting: 'Hey!' };
let d;

d = c;
c.greeting = 'Hello';
console.log(d.greeting);
```
<details>
  <summary>무엇이 출력될까?</summary>
    <>
    - 내답 : Hello
    - 이유? : 변수 d는 변수 c와 동일하다. c의 `greeting` 값이 `Hello`로 바뀌었으므로 d의 greeting 값 역시 `Hello`다.
    - 사족 : 만약 d가 `{ greeting: 'Hey!' }`의 값을 바인딩 했다면, 이는 표면적으로만 c와 동일할 뿐 새로운 객체가 된다. 그랬다면 c의 값변화와 상관없이 d.greeting은 `Hey!`를 출력할 것이다.
    - 오답노트 : 💯
    </>
</details>

### 6.
```js
let a = 3;
let b = new Number(3);
let c = 3;

console.log(a == b);
console.log(a === b);
console.log(b === c);
```
<details>
  <summary>무엇이 출력될까?</summary>
    <>
    - 답 : true, false, false
    - 이유? : `new Number` 인스턴스의 타입은 숫자가 아니라 객체다. typeof로 []를 찍었을 때 `object`가 나오듯.. 인스턴스들은 부모(또는 prototype)에 있는 다양한 메서드들을 상속(또는 위임) 받을 수 있다.  
    비교연산자 `==`의 준거는 값이고, `===`는 여기에 더해 타입까지 조응해야 한다. 변수 b의 타입은 `object`이고 나머지는 `number`이므로  콘솔에는 `true, false, false`가 찍힌다.
    - 사족 : 클래스와 프로토타입의 역할적 유사성(아니, 동일성) 때문에 둘을 자꾸 혼용해서 이해한다.. 
    - 오답노트 : ⚠️ (그래서 `Array`의 내장 함수들이 클래스에 의한 상속인지, 프로토타입에 의한 위임인지 다시 알아볼 것)
    </>
</details>

### 7. class에서 static의 역할
```js
class Chameleon {
  static colorChange(newColor) {
    this.newColor = newColor;
    return this.newColor;
  }

  constructor({ newColor = 'green' } = {}) {
    this.newColor = newColor;
  }
}

const freddie = new Chameleon({ newColor: 'purple' });
console.log(freddie.colorChange('orange'));
```
<details>
  <summary>무엇이 출력될까?</summary>
    <>
    - 내답 : TypeError
    - 이유? : 보라색 카멜레온을 잘 뽑긴 했지만, `colorChange` 메써드는 부모에서 `static`이기 때문에 인스턴스에선 사용할 수 없다. 
    - 사족 : `static`은 부모에서만 살아 있다.!
    - 오답노트 : -
    </>
</details>

### 8.
```js
let greeting;
greetign = {}; // 오타 발생!
console.log(greetign);

```
<details>
  <summary>무엇이 출력될까?</summary>
    <>
    - 내답 : `{}`
    - 이유? : 오타를 내서 허공(전역객체)에 빈 객체를 할당하고 있다. 하지만 자바스크립트는 유연하기 때문에 var 변수를 이용해 이를 저장해 놓는다. 따라서 `globalThis.greetign = {}`
    - 사족 : 설명이 맞나 모르겠다. greeting은 아직 할당을 받지 못해 `undefined`다.
    - 오답노트 : -
    </>
</details>

### 9.
```js
function bark() {
  console.log('Woof!');
}

bark.animal = 'dog';
```
<details>
  <summary>무슨일이 생길까?</summary>
    <>
    - 내답 : 별일 없다.
    - 이유? : 함수에 객체처럼 프로퍼티-값을 추가할 수 있을까? 있다. 자바스크립트에서 함수는 일급객체니까!
    - 사족 : 사실 자바스크립트에서 원시형(number, string, symbol 등등) 타입을 제외한 모든 타입은 객체 타입이다. __proto__를 확인해보면 된다.
    - 오답노트 : -
    </>
</details>

### 10.
```js
function Person(firstName, lastName) {
  this.firstName = firstName;
  this.lastName = lastName;
}

const member = new Person('Lydia', 'Hallie');
Person.getFullName = function () {
  return `${this.firstName} ${this.lastName}`;
};

console.log(member.getFullName());
```
<details>
  <summary>무엇이 출력될까?</summary>
    <>
    - 답 :
    - 이유? : 
    - 사족 : 
    - 오답노트 : -
    </>
</details>

### 11.
```js
function Person(firstName, lastName) {
  this.firstName = firstName;
  this.lastName = lastName;
}

const lydia = new Person('Lydia', 'Hallie');
const sarah = Person('Sarah', 'Smith');

console.log(lydia);
console.log(sarah);
```
<details>
  <summary>무엇이 출력될까?</summary>
    <>
    - 답 :
    - 이유? : 
    - 사족 : 
    - 오답노트 : -
    </>
</details>

### 12.
```js
A: Target > Capturing > Bubbling
B: Bubbling > Target > Capturing
C: Target > Bubbling > Capturing
D: Capturing > Target > Bubbling
```
<details>
  <summary>이벤트 전달의 순서는?</summary>
    <>
    - 내답 : D
    - 이유? : 캡처링을 통해 아래로 내려간 뒤, 버블링을 통해 위로 올라옴.
    - 사족 : -
    - 오답노트 : -
    </>
</details>

### 13.
```js
A: true
B: false
```
<details>
  <summary>모든 객체는 프로토 타입을 가진다?</summary>
    <>
    - 답 : true ❌
    - 이유? : 
    - 사족 : 
    - 오답노트 : 기본객체는 프로토타입을 가지지 않는다고 한다. 콘솔로 찍어보니 정말 `null` 이다.
    기본객체는? 사용자가 중괄호를 열어 만든 객체, 또는 `new Object()`로 만든 객체를 기본객체라고 한다.
    </>
</details>

### 14.
```js
function sum(a, b) {
  return a + b;
}

sum(1, '2');
```
<details>
  <summary>무엇이 출력될까?</summary>
    <>
    - 답 : 3 ❌
    - 이유? : 자바스크립트의 유연함 때문에 형변환이 일어난다.  
    - 사족 : 근데 형변환에 우선순위가 있나...?
    - 오답노트 : 있었다. 나는 앞선 인자의 타입(숫자)에 타입이 맞춰진다고 생각했는데, 답은 "12"였다. 숫자에 앞서 문자형으로 계산이 된 거다.
    </>
</details>

### 15.
```js
let number = 0;
console.log(number++);
console.log(++number);
console.log(number);
```
<details>
  <summary>무엇이 출력될까?</summary>
    <>
    - 답 : 0 2 2
    - 이유? : `number`가 읽힐 때 증감연산자의 위치에 따라 출력이 달라질 수 있다. 
    - 사족 : -
    - 오답노트 : -
    </>
</details>

### 16.
```js
function getPersonInfo(one, two, three) {
  console.log(one);
  console.log(two);
  console.log(three);
}

const person = 'Lydia';
const age = 21;

getPersonInfo`${person} is ${age} years old`;
```
<details>
  <summary>무엇이 출력될까?</summary>
    <>
    - 답 : "Lydia", 21, "["", " is ", " years old"]"
    - 이유? : `Template Literal` 부분을 인자로 받고, 나머지는 한번에 처리될 거라고 생각했다..
    - 사족 : 인자를 저렇게도 넣을 수 있구나 싶었음
    - 오답노트 : 정답은 반대였다..ㅎ 첫 번째 인자의 값이 항상 문자열 값의 배열이고, 나머지가 표현식을 통과한 값이라고 한다.
    </>
</details>

### 16.
```js
function checkAge(data) {
  if (data === { age: 18 }) {
    console.log('You are an adult!');
  } else if (data == { age: 18 }) {
    console.log('You are still an adult.');
  } else {
    console.log(`Hmm.. You don't have an age I guess`);
  }
}

checkAge({ age: 18 });
```
<details>
  <summary>무엇이 출력될까?</summary>
    <>
    - 답 : Hmm.. You don't have an age I guess
    - 이유? : 객체의 값은 주소값을 참조한다. 같은 키, 같은 값으로 보여도 각자의 메모리를 차지하는 것이라 객체 그 자체는 같은 부분이 없다.
    - 사족 : -
    - 오답노트 : - 
    </>
</details>

### 16. 
```js
function getAge(...args) {
  console.log(typeof args);
}

getAge(21);
```
<details>
  <summary>무엇이 출력될까?</summary>
    <>
    - 답 : object
    - 이유? : 배열은 `new Array()`의 인스턴스이고 그 타입은 `object`다.
    - 사족 : -
    - 오답노트 : - 
    </>
</details>

### 17. 'use strict'
```js
function getAge() {
  'use strict';
  age = 21;
  console.log(age);
}

getAge();
```
<details>
  <summary>무엇이 출력될까?</summary>
    <>
    - 답 : ReferenceError
    - 이유? : `use strict`를 쓸 경우 자바스크립트는 변수 누락을 인정해주지 않는다. `globalThis`에 바인드 해주는 대신 오류를 던진다. 
    - 사족 : -
    - 오답노트 : - 
    </>
</details>

### 18. 'use strict'
```js

```
<details>
  <summary>무엇이 출력될까?</summary>
    <>
    - 답 : 
    - 이유? : 
    - 사족 : -
    - 오답노트 : - 
    </>
</details>

### 18. eval
```js
const sum = eval('10*10+5')
```
<details>
  <summary>sum의 값을 무엇일까?</summary>
    <>
    - 답 : 105
    - 이유? : 
    - 사족 : -
    - 오답노트 : - 
    </>
</details>

### 19. sessionStorage
```js
sessionStorage.setItem('cool_secret', 123);
```
<details>
  <summary> cool_secret에 몇 시간이나 접근이 가능할까?</summary>
    <>
    - 답 : 사용자가 탭을 닫을 때
    - 이유? : sessionStorage 휘발 시기는 탭을 닫았을 때다. localStorage는 쿠키를 청소하거나 localStorage.clear(), localStorage.removeItem() 등의 코드를 실행했을 때 저장소가 비워진다.
    - 사족 : -
    - 오답노트 : - 
    </>
</details>

### 18. var 변수의 특성
```js
var num = 8;
var num = 10;

console.log(num);
```
<details>
  <summary>무엇이 출력될까?</summary>
    <>
    - 답 : 10
    - 이유? : var 변수는 재선언, 재할당이 가능한 변수다. 
    - 사족 : -
    - 오답노트 : - 
    </>
</details>

### 18. 오브젝트 프로퍼티의 타입
```js
const obj = { 1: 'a', 2: 'b', 3: 'c' };
const set = new Set([1, 2, 3, 4, 5]);

obj.hasOwnProperty('1');
obj.hasOwnProperty(1);
set.has('1');
set.has(1);
```
<details>
  <summary>무엇이 출력될까?</summary>
    <>
    - 답 : true, true, false, true
    - 이유? : 오브젝트의 프로퍼티는 기본적으로 문자이며, 숫자로 선언됐을 때는 문자도 숫자도 될 수 있다.
    - 사족 : -
    - 오답노트 : -
    </>
</details>

### 18. 오브젝트의 중복 프로퍼티
```js
const obj = { a: 'one', b: 'two', a: 'three' };
console.log(obj);
```
<details>
  <summary>무엇이 출력될까?</summary>
    <>
    - 답 : `{a: "three", b: "two"}`
    - 이유? : 동일한 키가 선언될 경우 마지막으로 덮어 쓴다. 타입스크립트에서는 경고를 띄운다.
    - 사족 : -
    - 오답노트 : - 
    </>
</details>

### 18. 반복문의 continue
```js
for (let i = 1; i < 5; i++) {
  if (i === 3) continue;
  console.log(i);
}
```
<details>
  <summary>무엇이 출력될까?</summary>
    <>
    - 답 : 1 2
    - 이유? : 조건문이 일치하면 반복문을 빠져 나간다. i가 3에 도달할 때 `console.log(i)` 실행 이전에 반복문이 종료된다.
    - 사족 : -
    - 오답노트 : 반복문을 빠져나가는 것이 아니라 그 조건의 턴을 건너 뛰는 것이다. 3일 경우 스킵되므로 답은 1 2 4.
    </>
</details>

### 18. 문자형의 프로토타입 메써드 주입
```js
String.prototype.giveLydiaPizza = () => {
  return 'Just give Lydia pizza already!';
};

const name = 'Lydia';

console.log(name.giveLydiaPizza())
```
<details>
  <summary>무엇이 출력될까?</summary>
    <>
    - 답 : "Just give Lydia pizza already!"
    - 이유? : String의 prototype에 giveLydiaPizza()를 심었다. 문자형인 name 변수는 이를 위임=귀속받는다.
    - 사족 : -
    - 오답노트 : - 
    </>
</details>

### 18. ["object Object"]
```js
const a = {};
const b = { key: 'b' };
const c = { key: 'c' };

a[b] = 123;
a[c] = 456;

console.log(a[b]);
```
<details>
  <summary>무엇이 출력될까?</summary>
    <>
    - 답 : 
    - 이유? :
    - 사족 : -
    - 오답노트 : - 
    </>
</details>

### 18. 스택, 큐, 루프
```js
const foo = () => console.log('First');
const bar = () => setTimeout(() => console.log('Second'));
const baz = () => console.log('Third');

bar();
foo();
baz();
```
<details>
  <summary>무엇이 출력될까?</summary>
    <>
    - 답 : First, Third, Second
    - 이유? : setTimeout()은 큐를 거쳐 루프로 빠지기 때문에 콜스택 후순위다.
    - 사족 : -
    - 오답노트 : - 
    </>
</details>

### 18. 'use strict'
```js
<div onclick="console.log('first div')">
  <div onclick="console.log('second div')">
    <button onclick="console.log('button')">Click!</button>
  </div>
</div>

```
<details>
  <summary>버튼을 클릭했을때 event.target은 무엇일까?</summary>
    <>
    - 답 : button
    - 이유? : 이벤트 일어나는 직접적인 곳, 그곳은 button이다. if문이나 e.stopPropagation을 활용해 버블링을 막을 수 있다.
    - 사족 : -
    - 오답노트 : - 
    </>
</details>

### 18. 이벤트 버블링
```js
<div onclick="console.log('div')">
  <p onclick="console.log('p')">Click here!</p>
</div>
```
<details>
  <summary>p태그를 클릭하면 출력된 로그는 무엇일까?</summary>
    <>
    - 답 : p div
    - 이유? : 이벤트 버블링이 일어나 다시 거슬러오를 때 부모 요소에도 이벤트를 발생시킨다. 
    - 사족 : -
    - 오답노트 : - 
    </>
</details>

### 18. call()과 bind()
```js
const person = { name: 'Lydia' };

function sayHi(age) {
  console.log(`${this.name} is ${age}`);
}

sayHi.call(person, 21);
sayHi.bind(person, 21);
```
<details>
  <summary>무엇이 출력될까?</summary>
    <>
    - 답 : Lydia is 21, Lydia is 21
    - 이유? : (`person`, 21)의 데이터를 바인딩해 함수 내부로 보낸다.
    - 사족 : -
    - 오답노트 : call()은 인자를 받고 바로 실행시키는 반면 bind()는 묶기만 할 뿐이다. 즉시 실행되지 않기에 log에 뜨는 것은 `function`이다.
    </>
</details>

### 18. 함수의 타입
```js
function sayHi() {
  return (() => 0)();
}

console.log(typeof sayHi());
```
<details>
  <summary>무엇이 출력될까?</summary>
    <>
    - 답 : "function"
    - 이유? : 리턴값이 무엇이든 일단 `function`이기 때문이다.
    - 사족 : -
    - 오답노트 : 바보. 완전 틀렸다. sayHi()는 즉시 호출 함수 표현식(IIFE)다. 말이 어렵지만 ()를 붙인 순간 이미 실행된 것. 따라서 0을 반환하고 타입은 `number`다.  
은 모두 `object`에 속한다.. 진짜 정신 차려야 한다.  
    </>
</details>

### 18. false값
```js
0;
new Number(0);
('');
(' ');
new Boolean(false);
undefined;
```
<details>
  <summary>이 값 중 어느 것이 거짓 같은 값일까</summary>
    <>
    - 답 : 0, (''), new Boolean(false), undefined
    - 이유? : 모두다 `false`로 취급되는 값들이다.
    - 사족 : -
    - 오답노트 : 생성자 함수의 타입은 `object`다. 값은 `false` 일지라도.
    </>
</details>

### 18. typeof의 반환값
```js
console.log(typeof typeof 1);
```
<details>
  <summary>무엇이 출력될까?</summary>
    <>
    - 답 : "string"
    - 이유? : typeof "number"의 타입은 "string"일 것이다.
    - 사족 : -
    - 오답노트 : - 
    </>
</details>

### 18. 배열의 빈자리
```js
const numbers = [1, 2, 3];
numbers[10] = 11;
console.log(numbers);
```
<details>
  <summary>무엇이 출력될까?</summary>
    <>
    - 답 : [1, 2, 3, 7 x null, 11]
    - 이유? : 3~10까지의 공백은 `null`값으로 대신된다.
    - 사족 : -
    - 오답노트 : `null`이 아닌 `empty slots`라는 것을 생성한다고 한다. 실질적으로 `undefined`와 동일한 값. 실행 위치(브라우저 or node)에 따라 달리 보인다고 함.
    </>
</details>

### 18. 변수와 파라미터
```js
(() => {
  let x, y;
  try {
    throw new Error();
  } catch (x) {
    (x = 1), (y = 2);
    console.log(x);
  }
  console.log(x);
  console.log(y);
})();
```
<details>
  <summary>무엇이 출력될까?</summary>
    <>
    - 답 : 1 undefined 2
    - 이유? : catch() 함수 내에서 `x=1`을 실행하지만 그 `x`는 catch의 파라미터로서의 x다. 외부의 x는 여전히 이니셜라이되지않 태. 반면 `y=2`는 외부의 변수 y에 맞닿음으로써 값을 가진다. 
    - 사족 : -
    - 오답노트 : - 
    </>
</details>

### 18. 'use strict'
```js
A: primitive 또는 object
B: function 또는 object
C: 함정 문제! objects만
D: number 또는 object
```
<details>
  <summary>무엇이 출력될까?</summary>
    <>
    - 답 : A
    - 이유? : 원시값들과 오브젝트들로 구성된 자바스크립트입니당 
    - 사족 : 원시형과 오브젝트를 구별하는 방법은 원시형에는 속성이나 메써드가 없는 것이다.! 하지만 원시형이 원시형의 인스턴스처럼 메써드를 갖다 써도 작동이 되는 모습을 볼 수 있는데, 자바스크립트는 원시형의 데이터에 임시로 이들의 래퍼 클래스를 적용해 표현식이 끝나는 즉시 바로 이를 폐기한다고 한다. 
    - 오답노트 : - 
    </>
</details>

### 18. 배열의 reduce 메써드
```js
[
  [0, 1],
  [2, 3],
].reduce(
  (acc, cur) => {
    return acc.concat(cur);
  },
  [1, 2]
);
```
<details>
  <summary>무엇이 출력될까?</summary>
    <>
    - 답 : [1, 2, 0, 1, 2, 3]
    - 이유? : 초기값은 [1, 2]고, 이어 배열 각각의 요소들을 이어붙이게 된다.
    - 사족 : -
    - 오답노트 : - 
    </>
</details>

### 18. 논리연산자 !
```js
!!null;
!!'';
!!1;
```
<details>
  <summary>무엇이 출력될까?</summary>
    <>
    - 답 : false false true
    - 이유? : 거짓으로 취급되는 값이 있다. `null`, `("")`, `undefined`, `NaN` ...
    - 사족 : -
    - 오답노트 : - 
    </>
</details>

### 18. 'use strict'
```js
setInterval(() => console.log('Hi'), 1000);
```
<details>
  <summary>setInterval 메소드는 브라우저에게 무엇을 반환할까?</summary>
    <>
    - 답 : 유니크한 id
    - 이유? : 내부의 함수라고 생각했지만, 효율적인 일처리를 위해 id값을 반환하지 않을까...?
    - 사족 : -
    - 오답노트 : `id` 값이 부여되고 clearInterval() 함수의 간격을 없애기 위해 사용될 수 있다고 하는데...
    </>
</details>

### 18. spread operator
```js
[...'Lydia'];
```
<details>
  <summary>무엇이 반환될까?</summary>
    <>
    - 답 : ["L", "y", "d", "i", "a"]
    - 이유? : 문자열 "Lydia"를 풀어놓는다.
    - 사족 : -
    - 오답노트 : - 
    </>
</details>

### generator 생성자 함수
```js
function* generator(i) {
  yield i;
  yield i * 2;
}

const gen = generator(10);

console.log(gen.next().value);
console.log(gen.next().value);
```
<details>
  <summary>무엇이 출력될까?</summary>
    <>
    - 답 : 10, 20
    - 이유? : next()로 제너레이터를 부를 때, 부른 횟수를 기억해서 그에 대응하는 값을 내보낸다.
    - 사족 : 세번째 `yeild`는 없으므로 그 이후의 호출은 `undefined`로 뜰 것이다.
    - 오답노트 : - 
    </>
</details>

### Propmise.race
```js
const firstPromise = new Promise((res, rej) => {
  setTimeout(res, 500, 'one');
});

const secondPromise = new Promise((res, rej) => {
  setTimeout(res, 100, 'two');
});

Promise.race([firstPromise, secondPromise]).then((res) => console.log(res));
```
<details>
  <summary>무엇이 출력될까?</summary>
    <>
    - 답 : one, two
    - 이유? : `race`라는 이름에서 짐작하여 일종의 `async` 효과를 내는 게 아닌가 생각했다. 첫번째 프로미스가 두번째 프로미스에게 바통을 넘기는 식으로 말이다.
    - 사족 : `race`를 처음 알게 됐다.
    - 오답노트 : 복수의 프로미스를 `Promise.race`에 넘겨주면, *최초의 프로미스를 해결/거부한다*. 이 상황에서 최초는 500ms를 가진 `secondPromise` 프로미스다. 따라서 그의 해결값인 `two`가 출력된다.
    </>
</details>

### 참조의 복사
```js
let person = { name: 'Lydia' };
const members = [person];
person = null;

console.log(members);
```
<details>
  <summary>무엇이 출력될까?</summary>
    <>
    - 답 : `[{ name: "Lydia" }]`
    - 이유? : 한 오브젝트를 등호로 같게 가져올 때 그건 값복사가 아닌 참조, 주소값의 복사다. 원 데이터인 `person`이 집({})을 버리고 형변환을 한대도 그건 집을 떠나는 것이지 무너뜨리는 것이 아니다. 따라서 `members`는 여전히 `{name: "Lydia"}`를 간직한다.
    - 사족 : -
    - 오답노트 : - 
    </>
</details>

### for ~ in 반복문
```js
const person = {
  name: 'Lydia',
  age: 21,
};

for (const item in person) {
  console.log(item);
}
```
<details>
  <summary>무엇이 출력될까?</summary>
    <>
    - 답 : name, age
    - 이유? : 프로퍼티만 넘긴다.
    - 사족 : Object.keys()의 내부동작으로 볼 수 있을 것 같다.
    - 오답노트 : - 
    </>
</details>

### 다른 타입 간의 덧셈
```js
console.log(3 + 4 + '5');
```
<details>
  <summary>무엇이 출력될까?</summary>
    <>
    - 답 : "75"
    - 이유? : 숫자 타입끼리 덧셈이 일어나고, 후에 "5"와 결합하면서 문자로 변형될 것이다.
    - 사족 : 앞선 문제에서도 나왔는데, 숫자+문자에서 우선순위는 문자쪽으로 쏠린다.
    - 오답노트 : - 
    </>
</details>

### parseInt
```js
const num = parseInt('7*6', 10);
```
<details>
  <summary>num의 값을 뭘까?</summary>
    <>
    - 답 : 42
    - 이유? : `parseInt`는 문자열을 인수로 받아 숫자로 변형시킨다. 두번째 인수는 n진수를 결정한다.
    - 사족 : -
    - 오답노트 : 정답은 `7`이다. 계산이 처리될 거라 생각했는데*, 파싱 단계에서 숫자가 아닌 문자를 만나면 진행을 중지한다*고 한다. 따라서 계산 대상으로 넘겨지는 것은 `7` 뿐이다.
    </>
</details>

### 함수의 return;
```js
[1, 2, 3].map((num) => {
  if (typeof num === 'number') return;
  return num * 2;
});
```
<details>
  <summary>무엇이 출력될까?</summary>
    <>
    - 답 : [3 x empty]
    - 이유? : 모두 숫자 타입이므로 `return 아무것도없음`이 넘겨진다. 이때 무슨 값으로 들어가냐가 관건인데 앞선 문제에서 봤듯 `empty`로 자리를 메꿀 거라 생각했다. 
    - 사족 : -
    - 오답노트 : 정답은 `[undefined x 3]`다. 함수는 값을 반환하지 않을 때 `undefined`를 내보낸다.
    </>
</details>

### 변수의 데이터 수정
```js
function getInfo(member, year) {
  member.name = 'Lydia';
  year = '1998';
}

const person = { name: 'Sarah' };
const birthYear = '1997';

getInfo(person, birthYear);

console.log(person, birthYear);
```
<details>
  <summary>무엇이 출력될까?</summary>
    <>
    - 답 : `{name: "Lydia"}, "1997"`
    - 이유? : 인수로 들어가면서 person은 내부값이 변환되어 저장된다. 반면 `birthYear`은 인수로 들어가 함수 내부에서만 값이 조정되는 것이고 그 원본값에는 영향을 받지 않는다.
    - 사족 : -
    - 오답노트 : - 
    </>
</details>

### throw 예외처리
```js
function greeting() {
  throw 'Hello world!';
}

function sayHi() {
  try {
    const data = greeting();
    console.log('It worked!', data);
  } catch (e) {
    console.log('Oh no an error:', e);
  }
}

sayHi();
```
<details>
  <summary>무엇이 출력될까?</summary>
    <>
    - 답 : "It worked! Hello world!"
    - 이유? : try 안에서 greeting()을 실행했고, 성공하여 빠져나간다.
    - 사족 : -
    - 오답노트 : `throw`는 `return`이 아니다. 예외처리에서의 `return`인데 try 블록 안에서 이를 읽으면 catch문으로 자연스레 빠지게 된다. catch(e)는 이 `throw`를 반환한다.
    </>
</details>

### class의 상속
```js
function Car() {
  this.make = 'Lamborghini';
  return { make: 'Maserati' };
}

const myCar = new Car();
console.log(myCar.make);
```
<details>
  <summary>무엇이 출력될까?</summary>
    <>
    - 답 : Lamborghini
    - 이유? : 생성자에 걸어놓은 `this.make`가 우선할 것 같다.
    - 사족 : -
    - 오답노트 : Maserati를 출력한다. 속성을 반환할 때, 속성값은 생성자에 설정한 값이 아닌, 반환된 값과 같다고 한다. 값이 겹칠 때 `return`이 우선.
    </>
</details>

### 화살표 함수 안에서 변수의 생명
```js
(() => {
  let x = (y = 10);
})();

console.log(typeof x);
console.log(typeof y);
```
<details>
  <summary>무엇이 출력될까?</summary>
    <>
    - 답 : "undefined", "number"
    - 이유? : 함수 바깥에서 `let x`는 알 수 없다. y는 자바스크립트에 의해 `globalThis.y`로 자의적으로 선언되기 때문에 밖에서도 읽을 수 있다.
    - 사족 : -
    - 오답노트 : -
    </>
</details>

### 프로토타입 접근
```js
class Dog {
  constructor(name) {
    this.name = name;
  }
}

Dog.prototype.bark = function () {
  console.log(`Woof I am ${this.name}`);
};

const pet = new Dog('Mara');

pet.bark();

delete Dog.prototype.bark;

pet.bark();
```
<details>
  <summary>무엇이 출력될까?</summary>
    <>
    - 답 : "Woof I am Mara", typeError
    - 이유? : Dog의 프로토타입에 bark()라는 메써드가 추가되었고 인스턴스인 pet은 그를 위임받는다. 이어 삭제를 거치는데, 함수가 아닌 것을 함수처럼 실행하려 했기 때문에 `typeError` 오류를 던진다.
    - 사족 : 프로토타입도 객체다. 따라서 `delete`를 사용해 속성을 삭제할 수 있다.
    - 오답노트 : - 
    </>
</details>

### Set 제너레이터
```js
const set = new Set([1, 1, 2, 3, 4]);

console.log(set);
```
<details>
  <summary>무엇이 출력될까?</summary>
    <>
    - 답 : `{1, 2, 3, 4}`
    - 이유? : Set 제너레이터는 중복값을 없앤 객체를 반환한다.
    - 사족 : 다시 배열로 만들 때 spread operator 또는 Array.from() 활용할 수 있다. [...set]
    - 오답노트 : - 
    </>
</details>

### 모듈 import
```js counter.js
let counter = 10;
export default counter;
```
```js index.js
import myCounter from './counter';

myCounter += 1;

console.log(myCounter);
```
<details>
  <summary>무엇이 출력될까?</summary>
    <>
    - 답 : 11
    - 이유? : `defalut`로 내보낸 값 `counter`를 `myCounter`로 이름붙여 가져왔다. 이 값은 10이었으므로 1을 증가시키면 11이 된다.
    - 사족 : -
    - 오답노트 : 정답은 `Error`다. import된 모듈은 `read-only`다..
    </>
</details>

### delete operator
```js
const name = "Lydia";
age = 21;

console.log(delete name);
console.log(delete age);
```
<details>
  <summary>무엇이 출력될까?</summary>
    <>
    - 답 : false, true
    - 이유? : 임의로 선언된 age는 `globalThis.age`, 즉 전역객체의 속성으로 들어간다. `delete` 오퍼레이터는 객체의 속성을 제거하는 연산자다.
    - 사족 : var, const 또는 let 키워드로 선언된 변수은 delete 연산자를 사용해서 삭제될 수 없다고 한다. 
    - 오답노트 : - 
    </>
</details>

### 디스터럭션
```js
const numbers = [1, 2, 3, 4, 5];
const [y] = numbers;

console.log(y);
```
<details>
  <summary>무엇이 출력될까?</summary>
    <>
    - 답 : 1
    - 이유? : 디스트럭션 원칙이 적용돼 배열의 첫번째 요소가 출력된다.
    - 사족 : -
    - 오답노트 : - 
    </>
</details>

### spread operator
```js
const user = { name: 'Lydia', age: 21 };
const admin = { admin: true, ...user };

console.log(admin);
```
<details>
  <summary>무엇이 출력될까?</summary>
    <>
    - 답 : `{ admin: true, name: "Lydia", age: 21 }`
    - 이유? : 스프레드 오퍼레이터를 사용해 user의 값을 복사=풀어놨다.
    - 사족 : -
    - 오답노트 : - 
    </>
</details>

### JSON.stringify
```js
const settings = {
  username: 'lydiahallie',
  level: 19,
  health: 90,
};

const data = JSON.stringify(settings, ['level', 'health']);
console.log(data);
```
<details>
  <summary>무엇이 출력될까?</summary>
    <>
    - 답 : `"{"level": 19, "health": 90}"`
    - 이유? : 객체를 제이슨화했다. 두번째 인수는 일종의 필터링 역할을 하여 조건을 충족(해당되는) 프로퍼티만 반환하게 만든다.
    - 사족 : 두번째 인자를 `replacer`라고 부르며, 배열 또는 함수가 올 수 있다. 함수일 경우 함수의 리턴값이 JSON 문자열에 추가할 속성의 값이 된다.
    - 오답노트 : - 
    </>
</details>

### ++ 단항 연산자의 위치
```js
let num = 10;

const increaseNumber = () => num++;
const increasePassedNumber = number => number++;

const num1 = increaseNumber();
const num2 = increasePassedNumber(num1);

console.log(num1);
console.log(num2);
```
<details>
  <summary>무엇이 출력될까?</summary>
    <>
    - 답 : 11, 12
    - 이유? : unary operator ++의 계산에 의해 값이 증가한다.
    - 사족 : -
    - 오답노트 : 순서를 잘 봐야 한다. 출력되는 부분은 변수 부분이고 계산은 그다음이다. 첫번째 함수로 리턴되는 값은 10이며, 후에 값이 1 증가한다. (전역변수 num = 11) num1의 값은 여전히 10이며, num2에서도 같은 일이 되풀이 된다. 따라서 10, 10이 찍힌다.
    </>
</details>

### 디폴트 파라미터
```js
const value = { number: 10 };

const multiply = (x = { ...value }) => {
  console.log((x.number *= 2));
};

multiply();
multiply();
multiply(value);
multiply(value);
```
<details>
  <summary>무엇이 출력될까?</summary>
    <>
    - 답 : 20, 20, 20, 40
    - 이유? : 디폴트로 value값을 복사하여 가져온다. 이때 참조값을 복사하여 계산해도 원본값은 그대로이기 때문에 두번 거듭해도 값은 20이다. 반면 원본값을 인자로 받았을 땐 계산된 값이 반영되기 때문에 값이 40으로 늘어난다.
    - 사족 : -
    - 오답노트 : - 
    </>
</details>

### Array.reduce()
```js
[1, 2, 3, 4].reduce((x, y) => console.log(x, y));
```
<details>
  <summary>무엇이 출력될까?</summary>
    <>
    - 답 : 1, 2 / undefined, 3 / undefined, 4
    - 이유? : x의 자리는 누적값(Accumlate) y의 자리는 현재값(Current)이 들어온다. 세번째 인수인 초기값이 비어있기 때문에 배열의 첫번째 요소가 초기값이 되도록 두번째 요소부터 함수가 실행된다. 즉 x(acc)= 1, y(cur)=2가 출력된다. 현재값 y는 이렇게 계속 진행한다. x의 값으로는 return에 의해 설계된 어떤 누적값이 들어와야 하지만, 여기서는 아무것도 계산되지 않기에 `undefined`를 띄운다.
    - 사족 : -
    - 오답노트 : - 
    </>
</details>

### 부모-자식 클래스
```js
class Dog {
  constructor(name) {
    this.name = name;
  }
};

class Labrador extends Dog {
  // 1
  constructor(name, size) {
    this.size = size;
  }
  // 2
  constructor(name, size) {
    super(name);
    this.size = size;
  }
  // 3
  constructor(size) {
    super(name);
    this.size = size;
  }
  // 4
  constructor(name, size) {
    this.name = name;
    this.size = size;
  }

};
```
<details>
  <summary>Dog 클래스를 성공적으로 확장할 수 있는 생성자는 어느 것일까?</summary>
    <>
    - 답 : 2
    - 이유? : 인수로 name을 넘겨받고 이는 부모 클래스에 super()로 넘긴다. 
    - 사족 : 자식 클래스는 super()를 부르기 전까지 `this` 키워드에 접근할 수 없다.
    - 오답노트 : - 
    </>
</details>

### Import
```js index.js
console.log('running index.js');
import { sum } from './sum.js';
console.log(sum(1, 2));
```
```js sum.js
console.log('running sum.js');
export const sum = (a, b) => a + b;
```
<details>
  <summary>무엇이 출력될까?</summary>
    <>
    - 답 : `running sum.js`, `running index.js`, `3`
    - 이유? : `import`된 모듈부터 먼저 파싱된다.
    - 사족 : `require()`은 코드가 등장한 시점에 모듈을 로드한다는 점에서 둘의 차이가 있다.
    - 오답노트 : - 
    </>
</details>
