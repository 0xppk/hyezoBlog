---
title: 자바스크립트 자가진단 2
date: '2022-11-09'
categories: coding
tags: 자바스크립트
description: 2nd
---
<HeadingNavigator />

### 16. 인수와 template literal
```js
function getPersonInfo(one, two, three) {
  console.log(one);
  console.log(two);
  console.log(three);
}

const person = 'Lydia';
const age = 21;

getPersonInfo`${person} is ${age} years old`;
```
<details>
  <summary>무엇이 출력될까?</summary>
    <>
    - 내 생각 : "Lydia", 21, "["", " is ", " years old"]"
    - 이유? : `Template Literal` 부분을 인자로 받고, 나머지는 한번에 처리될 거라고 생각했다..
    - 사족 : 인자를 저렇게도 넣을 수 있구나 싶었음
    - 오답노트 : 정답은 반대였다..ㅎ 첫 번째 인자의 값이 항상 문자열 값의 배열이고, 나머지가 표현식을 통과한 값이라고 한다.
    </>
</details>

### 17. 객체의 동일성
```js
function checkAge(data) {
  if (data === { age: 18 }) {
    console.log('You are an adult!');
  } else if (data == { age: 18 }) {
    console.log('You are still an adult.');
  } else {
    console.log(`Hmm.. You don't have an age I guess`);
  }
}

checkAge({ age: 18 });
```
<details>
  <summary>무엇이 출력될까?</summary>
    <>
    - 내 생각 : Hmm.. You don't have an age I guess
    - 이유? : 객체의 값은 주소값을 참조한다. 같은 키, 같은 값일지라도 각자의 메모리를 차지하는 것이고 이는 엄연히 다른 객체다.
    - 사족 : -
    - 오답노트 : - 
    </>
</details>

### 18. rest parameter의 타입
```js
function getAge(...args) {
  console.log(typeof args);
}

getAge(21);
```
<details>
  <summary>무엇이 출력될까?</summary>
    <>
    - 내 생각 : object
    - 이유? : 배열은 `new Array()`의 인스턴스고 그 타입은 `object`다.
    - 사족 : -
    - 오답노트 : - 
    </>
</details>

### 19. use strict
```js
function getAge() {
  'use strict';
  age = 21;
  console.log(age);
}

getAge();
```
<details>
  <summary>무엇이 출력될까?</summary>
    <>
    - 내 생각 : ReferenceError
    - 이유? : `use strict`를 쓸 경우 자바스크립트는 변수 누락을 인정해주지 않는다. `globalThis`에 바인드 해주는 대신 오류를 던진다. 
    - 사족 : -
    - 오답노트 : - 
    </>
</details>

### 20. ??
```js

```
<details>
  <summary>무엇이 출력될까?</summary>
    <>
    - 내 생각 : 
    - 이유? : 
    - 사족 : -
    - 오답노트 : - 
    </>
</details>

### 21. eval
```js
const sum = eval('10*10+5')
```
<details>
  <summary>sum의 값을 무엇일까?</summary>
    <>
    - 내 생각 : 105
    - 이유? : 
    - 사족 : -
    - 오답노트 : - 
    </>
</details>

### 22. sessionStorage
```js
sessionStorage.setItem('cool_secret', 123);
```
<details>
  <summary> cool_secret에 몇 시간이나 접근이 가능할까?</summary>
    <>
    - 내 생각 : 사용자가 탭을 닫을 때
    - 이유? : sessionStorage 휘발 시기는 탭을 닫았을 때다. localStorage는 쿠키를 청소하거나 localStorage.clear(), localStorage.removeItem() 등의 코드를 실행했을 때 저장소가 비워진다.
    - 사족 : -
    - 오답노트 : - 
    </>
</details>

### 23. var 변수의 특성
```js
var num = 8;
var num = 10;

console.log(num);
```
<details>
  <summary>무엇이 출력될까?</summary>
    <>
    - 내 생각 : 10
    - 이유? : var 변수는 재선언, 재할당이 가능한 변수다. 
    - 사족 : -
    - 오답노트 : - 
    </>
</details>

### 24. 오브젝트 프로퍼티의 타입
```js
const obj = { 1: 'a', 2: 'b', 3: 'c' };
const set = new Set([1, 2, 3, 4, 5]);

obj.hasOwnProperty('1');
obj.hasOwnProperty(1);
set.has('1');
set.has(1);
```
<details>
  <summary>무엇이 출력될까?</summary>
    <>
    - 내 생각 : true, true, false, true
    - 이유? : 오브젝트의 프로퍼티는 기본적으로 문자이며, 숫자로 선언됐을 때는 문자도 숫자도 될 수 있다.
    - 사족 : -
    - 오답노트 : -
    </>
</details>

### 25. 오브젝트의 중복 프로퍼티 처리
```js
const obj = { a: 'one', b: 'two', a: 'three' };
console.log(obj);
```
<details>
  <summary>무엇이 출력될까?</summary>
    <>
    - 내 생각 : `{a: "three", b: "two"}`
    - 이유? : 동일한 키가 선언될 경우 마지막으로 덮어 쓴다. 타입스크립트에서는 경고를 띄운다.
    - 사족 : -
    - 오답노트 : - 
    </>
</details>

### 26. 반복문의 continue
```js
for (let i = 1; i < 5; i++) {
  if (i === 3) continue;
  console.log(i);
}
```
<details>
  <summary>무엇이 출력될까?</summary>
    <>
    - 내 생각 : 1 2
    - 이유? : 조건문이 일치하면 반복문을 빠져 나간다. i가 3에 도달할 때 `console.log(i)` 실행 이전에 반복문이 종료된다.
    - 사족 : -
    - 오답노트 : 반복문을 빠져나가는 것이 아니라 그 조건의 턴을 건너 뛰는 것이다. 3일 경우 스킵되므로 답은 1 2 4.
    </>
</details>

### 27. 문자형의 프로토타입 메써드 주입
```js
String.prototype.giveLydiaPizza = () => {
  return 'Just give Lydia pizza already!';
};

const name = 'Lydia';

console.log(name.giveLydiaPizza())
```
<details>
  <summary>무엇이 출력될까?</summary>
    <>
    - 내 생각 : "Just give Lydia pizza already!"
    - 이유? : String의 prototype에 giveLydiaPizza()를 심었다. 문자형인 name 변수는 이를 위임=귀속받는다.
    - 사족 : -
    - 오답노트 : - 
    </>
</details>

### 28. ["object Object"]
```js
const a = {};
const b = { key: 'b' };
const c = { key: 'c' };

a[b] = 123;
a[c] = 456;

console.log(a[b]);
```
<details>
  <summary>무엇이 출력될까?</summary>
    <>
    - 내 생각 : 
    - 이유? :
    - 사족 : -
    - 오답노트 : - 
    </>
</details>

### 29. 스택, 큐, 루프
```js
const foo = () => console.log('First');
const bar = () => setTimeout(() => console.log('Second'));
const baz = () => console.log('Third');

bar();
foo();
baz();
```
<details>
  <summary>무엇이 출력될까?</summary>
    <>
    - 내 생각 : First, Third, Second
    - 이유? : setTimeout()은 큐를 거쳐 루프로 빠지기 때문에 콜스택 후순위다.
    - 사족 : -
    - 오답노트 : - 
    </>
</details>

### 30. 이벤트 타겟
```js
<div onclick="console.log('first div')">
  <div onclick="console.log('second div')">
    <button onclick="console.log('button')">Click!</button>
  </div>
</div>

```
<details>
  <summary>버튼을 클릭했을때 event.target은 무엇일까?</summary>
    <>
    - 내 생각 : button
    - 이유? : 이벤트 일어나는 직접적인 곳, 그곳은 button이다. if문이나 e.stopPropagation을 활용해 버블링을 막을 수 있다.
    - 사족 : -
    - 오답노트 : - 
    </>
</details>


