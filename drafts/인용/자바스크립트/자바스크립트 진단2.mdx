---
title: 자바스크립트 자가진단 2
date: '2022-11-09'
categories: coding
tags: 자바스크립트
description: 2nd
---
<HeadingNavigator />

점수 : `13/15`

### 16. 템플릿 리터럴
```js
function getPersonInfo(one, two, three) {
  console.log(one);
  console.log(two);
  console.log(three);
}

const person = 'Lydia';
const age = 21;

getPersonInfo`${person} is ${age} years old`;
```
<details>
  <summary>무엇이 출력될까?</summary>
    <>
    - 내 생각 : "Lydia", 21, "["", " is ", " years old"]"
    - 이유? : `Template Literal`의 변수(표현식) 부분을 인자로 받고, 나머지는 한번에 처리될 거라고 생각했다.
    ---
    - 오답노트 : 정답은 반대였다..ㅎ 첫 번째 인수에 문자열 값의 배열이 들어가고, 나머지가 표현식을 통과한 값이라고 한다.
    - 사족 : 만약 `${age}`가 표현식이 아니라면 제공되는 인수는 두 개가 된다. 따라서 세번째 파라미터는 채워지지 않고 `undefined`를 내보낸다.
    </>
</details>

### 17. 객체의 동일성
```js
function checkAge(data) {
  if (data === { age: 18 }) {
    console.log('You are an adult!');
  } else if (data == { age: 18 }) {
    console.log('You are still an adult.');
  } else {
    console.log(`Hmm.. You don't have an age I guess`);
  }
}

checkAge({ age: 18 });
```
<details>
  <summary>무엇이 출력될까?</summary>
    <>
    - 내 생각 : `Hmm.. You don't have an age I guess`
    - 이유? : 오브젝트 데이터는 주소값을 참조한다. 가지고 있는 프로퍼티와는 무관하다. 오브젝트의 중괄호는 하나의 집, 주소를 의미하고, 이들은 각자의 메모리를 차지한다.
    ---
    - 사족 : -
    - 오답노트 : - 
    </>
</details>

### 18. rest parameter의 타입
```js
function getAge(...args) {
  console.log(typeof args);
}

getAge(21);
```
<details>
  <summary>무엇이 출력될까?</summary>
    <>
    - 내 생각 : `object`
    - 이유? : `rest parameter`는 배열 안에 담긴다. 배열은 `Array 제너레이터`의 인스턴스다. 그리고 모든 인스턴스들은 `object`다.
    ---
    - 사족 : -
    - 오답노트 : - 
    </>
</details>

### 19. 'use strict'
```js
function getAge() {
  'use strict';
  age = 21;
  console.log(age);
}

getAge();
```
<details>
  <summary>무엇이 출력될까?</summary>
    <>
    - 내 생각 : `ReferenceError`
    - 이유? : `use strict`를 쓸 경우 자바스크립트는 좀 더 엄정하게 변한다. 이 경우 변수 누락을 허용해주지 않는다. 원래라면 임시로 `var`를 붙여 `globalThis`에 선언을 묶어주었겠지만 여기선 외면한다. 접근, 참조할 수 없는 것을 호출했으므로 ReferenceError가 날 것이다.
    ---
    - 사족 : -
    - 오답노트 : - 
    </>
</details>

### 20. Dot/Bracket Notation
```js
const bird = {
  size: 'small',
};

const mouse = {
  name: 'Mickey',
  small: true,
};
// A: mouse.bird.size is not valid
// B: mouse[bird.size] is not valid
// C: mouse[bird["size"]] is not valid
// D: All of them are valid
```
<details>
  <summary>무엇이 참일까?</summary>
    <>
    - 내 생각 : `mouse.bird.size is not valid`
    - 이유? : 오브젝트 내부를 탐사하는 방법으로 `Dot Notation`과 `Bracket Notation`이 있다. 내가 이해하기로 `Dot`은 파이프라인처럼, 앞에서 차례로 읽어나간다. 반면 `Bracket`은 괄호 안의 값부터 계산해서 안에서부터 밖으로 퍼져나간다.  
    mouse에서는 bird라는 키는 찾을 수 없기 때문에 그 값은 `undefined`다.
    ---
    - 사족 : -
    - 오답노트 : - 
    </>
</details>

### 21. eval()
```js
const sum = eval('10*10+5')
```
<details>
  <summary>sum의 값은 무엇일까?</summary>
    <>
    - 내 생각 : `105`
    - 이유? : 잘 모르겠다. 뉘앙스에서 뭔가를 valuate한다는 느낌을 받았다. 주어진 인수는 계산식이지만 string 타입이다. 뭔가 숫자로 된 string타입을 number타입으로 전환시키지 않을까? 
    ---
    - 사족 : 그렇다고 한다. 문자열로 통과된 인수를 평가한다.
    - 오답노트 : - 
    </>
</details>

### 22. sessionStorage
```js
sessionStorage.setItem('cool_secret', 123);
```
<details>
  <summary>cool_secret에 몇 시간이나 접근이 가능할까?</summary>
    <>
    - 내 생각 : `사용자가 탭을 닫을 때`
    - 이유? : `sessionStorage`는 탭을 닫았을 때 휘발된다. 반면 `localStorage`는 쿠키를 청소하거나 `localStorage.clear()`, `localStorage.removeItem()` 등의 코드를 실행했을 때 비워진다.
    ---
    - 사족 : -
    - 오답노트 : - 
    </>
</details>

### 23. var 변수의 특성
```js
var num = 8;
var num = 10;

console.log(num);
```
<details>
  <summary>무엇이 출력될까?</summary>
    <>
    - 내 생각 : `10`
    - 이유? : var 변수는 재선언, 재할당이 가능한 변수다.
    --- 
    - 사족 : `let`은 재선언이 불가능하지만 재할당은 가능하다. `const`는 재선언도, 재할당도 불가능하다(하지만 객체 내부의 프로퍼티는 수정할 수 있다).
    - 오답노트 : - 
    </>
</details>

### 24. 오브젝트 키, set의 키
```js
const obj = { 1: 'a', 2: 'b', 3: 'c' };
const set = new Set([1, 2, 3, 4, 5]);

obj.hasOwnProperty('1');
obj.hasOwnProperty(1);
set.has('1');
set.has(1);
```
<details>
  <summary>무엇이 출력될까?</summary>
    <>
    - 내 생각 : `true`, `true`, `false`, `true`
    - 이유? : 오브젝트의 키는 기본적으로 문자이며, 숫자로 선언됐을 때는 문자도 숫자도 될 수 있다. 이건 `set`에서는 허용되지 않는다.
    ---
    - 사족 : `Symbol`인 경우를 제외할 때의 얘기다. 심볼로 키를 설정할 경우 그 값은 항상 고유값이다.  
    또한 `set 제너레이터`는 반복가능한 타입(문자, 배열)을 인수로 받을 수 있다. 배열을 넣을 경우 각각의 요소를 *중복없이* 자신의 값으로 삼는다. 이런 `set` 인스턴스는(빈 객체일 때도) 보통 오브젝트와 달리 반복 가능한 속성을 가진다.
    - 오답노트 : -
    </>
</details>

### 25. 오브젝트의 중복키 처리
```js
const obj = { a: 'one', b: 'two', a: 'three' };
console.log(obj);
```
<details>
  <summary>무엇이 출력될까?</summary>
    <>
    - 내 생각 : `{a: "three", b: "two"}`
    - 이유? : 동일한 키가 선언될 경우 마지막에 할당된 값으로 덮어 쓴다.
    ---
    - 사족 : -
    - 오답노트 : - 
    </>
</details>

### 26. 반복문의 continue
```js
for (let i = 1; i < 5; i++) {
  if (i === 3) continue;
  console.log(i);
}
```
<details>
  <summary>무엇이 출력될까?</summary>
    <>
    - 내 생각 : `1`, `2`
    - 이유? : 조건문이 일치하면 반복문을 빠져 나간다. i가 3에 도달할 때 `console.log(i)` 실행 이전에 반복문이 종료된다.
    ---
    - 오답노트 : 반복문을 빠져나가는 것이 아니라 그 조건을 충족하는 턴을 *건너뛴다*. 여기서는 `3`일 경우 스킵된다. 답은 `1`, `2`, `4`.
    - 사족 : -
    </>
</details>

### 27. 프로토타입
```js
String.prototype.giveLydiaPizza = () => {
  return 'Just give Lydia pizza already!';
};

const name = 'Lydia';

console.log(name.giveLydiaPizza())
```
<details>
  <summary>무엇이 출력될까?</summary>
    <>
    - 내 생각 : "Just give Lydia pizza already!"
    - 이유? : String의 prototype에 giveLydiaPizza()를 심었다. 문자형인 name 변수는 이를 위임, 물려 받는다.
    ---
    - 사족 : -
    - 오답노트 : - 
    </>
</details>

### 28. ["object Object"]
```js
const a = {};
const b = { key: 'b' };
const c = { key: 'c' };

a[b] = 123;
a[c] = 456;

console.log(a[b]);
```
<details>
  <summary>무엇이 출력될까?</summary>
    <>
    - 내 생각 : 
    - 이유? : 오브젝트의 키값은 기본적으로 문자형이다. 숫자도 문자로 읽는다. 그런데 이 자리에 오브젝트가 배정됐다. 오브젝트를 문자형으로 접근할 때 리턴되는 값은 `"[object Obejct]"`다.  
    여기서는 a["[object Object]"]에 대한 할당이 두번 이루어졌다. 마지막 기록이 남고, `a[b]`를 출력하더라도 이는 a["[object Object]"]와 마찬가지이기에 `456`을 출력한다.
    ---
    - 사족 : -
    - 오답노트 : - 
    </>
</details>

### 29. 콜스택, 큐, 루프
```js
const foo = () => console.log('First');
const bar = () => setTimeout(() => console.log('Second'));
const baz = () => console.log('Third');

bar();
foo();
baz();
```
<details>
  <summary>무엇이 출력될까?</summary>
    <>
    - 내 생각 : `First`, `Third`, `Second`
    - 이유? : `setTimeout()`은 큐를 거쳐 루프로 빠지기 때문에 콜스택 후순위다.
    ---
    - 사족 : 정확히 말하면 `setTimeout()` 콜백함수는 `WEB API`에 의해 처리된다. 이에 의해 처음부터 콜스택으로 들어가는 것이 아니라 큐의 후순위로 자리잡는다. 콜스택에 쌓여 있는 코드들이 모두 없어진 뒤, 루프가 돌면서 콜스택으로 올라간다. 
    - 오답노트 : - 
    </>
</details>

### 30. 이벤트 타겟
```js
<div onclick="console.log('first div')">
  <div onclick="console.log('second div')">
    <button onclick="console.log('button')">Click!</button>
  </div>
</div>

```
<details>
  <summary>버튼을 클릭했을때 event.target은 무엇일까?</summary>
    <>
    - 내 생각 : button
    - 이유? : 이벤트 일어나는 직접적인 곳, 그곳은 button이다. `if`문이나 `e.stopPropagation`을 활용해 버블링을 막을 수 있다.
    ---
    - 사족 : -
    - 오답노트 : - 
    </>
</details>


